import socket
from _thread import *
import threading
from tkinter import *
from time import sleep

# send becomes a thread after creating socket, and immediately transmits strings when a transmission input is generated by the user.
def send(socket):
    global go_send  # global variable in function
    while True:
        if go_send:
            # Get the string from the text widget to the position of the first and last characters.
            # The rstrip method removes the end of the specified string in a string (default is whitespace).
            message = (message_input.get(1.0,"end")).rstrip()
            socket.send(message.encode())   # send a string
            message_input.delete(1.0, "end")    # After sending the string, delete the text widget string.
            go_send = False # set global variable 'go_send' to false
        else:
            if go_out:
                socket.close() # Release socket when pressing logout button
                exit() # terminate the function to end the infinite loop
            sleep(0.1)

# receive is the receiving input processing thread after creating socket
def receive(socket):
    first = True
    while True:
        try:
            data = socket.recv(1024)   # wait until input is received (block function)
            chat_log['state'] = 'normal' # Change text widget input to editable state
            if first: # It is not efficient to do this because it is checked every time without meaning after the first check.
                chat_log.insert("end",str(data.decode( )))  # Display received data in text widget
                first = False
            else:
                chat_log.insert("end",'\n' + str(data.decode())) # Display the received data by inserting it at the end when it is not the beginning of the received data
                chat_log.see('end') # Return True if text appears at the end position

            chat_log['state'] = 'disabled'  # Change text widget state to disabled state
        except ConnectionAbortedError as e: # exception handling
            chat_log['state'] = 'normal'    # Switch text widget to normal state
            chat_log.insert("end", '\n[System] 접속을 종료합니다.\n') # Display the input string at the end of the display string in the text widget
            chat_log['state'] = 'disabled' # Switch to text widget state disabled
            exit()  # Termination of infinite loop in exception handling error state (escape)

# Thread that runs when the login button is pressed
def login():
    host = ip_entry.get(); port = int(port_entry.get()) # Get the server's IP address from the IP entry widget and the server's port from the port entry widget.
    client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  # Create client socket
    client_socket.connect((host, port)) # Connect the client socket to TCP/IP
    threading.Thread(target=send, args= (client_socket,)).start()  # Create a send thread. A client_socket object is given as an argument.
    threading.Thread(target=receive, args= (client_socket,)).start()  # Create a receive thread. A client_socket object is given as an argument.
    exit()

# Execute when the login button is pressed
def try_login():
    global go_out  # global variable in function
    start_new_thread(login,())  # create login thread
    login_button['state'] = 'disabled'  # Set login button state to disabled
    logout_button['state'] = 'active'   # Set logout button state to active
    ip_entry['state'] = 'readonly'  # Set IP entry widget: read only
    port_entry['state'] = 'readonly' # Set port entry widget: read only
    go_out = False  # Set go_out

# Execute when logout button is pressed
def try_logout():
    global go_out  # global variable in function
    login_button['state'] = 'active'  # Set the login button state to active
    logout_button['state'] = 'disabled' # Set logout button state to disabled
    ip_entry['state'] = 'normal'  # Set IP entry widget to normal
    port_entry['state'] = 'normal'  # Set port entry widget to normal
    go_out = True # Set global variable inside function

# When the send button is pressed, it is executed and data is transmitted in the send(socket) thread by the variable status of this function.
def set_go_send(event):
    global go_send  # global variable in function
    go_send = True  # Set global variable

go_out, go_send = False, False # global variable
c_root = Tk()   # tkinter is a standard Python interface to GUIs and can create Window windows, and tkinter.Tk() returns a window instance.
c_root.geometry('500x500')  # set window size
c_root.title('Client')  # set window title name
c_root.resizable(False, False)  # Fix window frame

Label(c_root, text = 'Server IP : ').place(x=20, y=20)  # Set label widget creation server IP and location
Label(c_root, text = 'Port       : ').place(x=20, y=40) # Set the label widget creation port and location

ip_entry = Entry(c_root, width=14); ip_entry.place(x=83, y=21)  # Create server IP entry widget and set location
ip_entry.insert(0, '127.0.0.1') # Insert default server IP entry widget value
port_entry = Entry(c_root, width=5); port_entry.place(x=83, y=42) # Create port entry widget and set location
port_entry.insert(0, '8000') # Insert value of port entry widget
login_button = Button(c_root, text = 'Log In', command=try_login); login_button.place(x=350, y=18) # Create and Position the login button widget
logout_button = Button(c_root, text = 'Log Out', state = 'disabled', command=try_logout); logout_button.place(x=405, y=18) # Create logout button widget and set its location

chat_frame = Frame(c_root)  # Create frame widget
scrollbar = Scrollbar(chat_frame) ; scrollbar.pack(side = 'right', fill = 'y')  # Create a scroll bar in the frame widget and align it to the right by pack
# Creating text widgets in frame widgets and arranging their positions by pack, the pack placement manager stacks widgets vertically according to the order in which they are added by default.
chat_log = Text(chat_frame, width=62, height=24, state = 'disabled', yscrollcommand=scrollbar.set) ; chat_log.pack(side = 'left')
scrollbar['command'] = chat_log.yview   # Set the y-axis of the text widget to the direction of the scroll bar
chat_frame.place(x=20, y=80)  # Set frame widget position
message_input = Text(c_root, width=55, height=4) ; message_input.place(x=20, y=410) # Create and Position a text widget for sending messages

# The send button widget is created and positioned, and the set_go_send function is executed when the button is pressed.
send_button = Button(c_root, text = ' Send ', command = lambda: set_go_send(None)); send_button.place(x=420, y=415)
# Execute the set_go_send function when Enter is entered as a message input text widget, and the input string can be sent only by entering enter without pressing the send button
message_input.bind("<Return>",set_go_send)

close_button = Button(c_root, text='  Close ', command=exit); close_button.place(x=350, y=45)  # Exit when close button is pressed
# Create widgets in multiple modules, not behind the Tkinter code, set triggers, and use them at the end of the execution flow to 'keep waiting' for user input
c_root.mainloop()